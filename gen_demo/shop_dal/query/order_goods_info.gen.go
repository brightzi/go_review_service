// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"gen_demo/dal/model"
)

func newOrderGoodsInfo(db *gorm.DB, opts ...gen.DOOption) orderGoodsInfo {
	_orderGoodsInfo := orderGoodsInfo{}

	_orderGoodsInfo.orderGoodsInfoDo.UseDB(db, opts...)
	_orderGoodsInfo.orderGoodsInfoDo.UseModel(&model.OrderGoodsInfo{})

	tableName := _orderGoodsInfo.orderGoodsInfoDo.TableName()
	_orderGoodsInfo.ALL = field.NewAsterisk(tableName)
	_orderGoodsInfo.ID = field.NewInt32(tableName, "id")
	_orderGoodsInfo.OrderID = field.NewInt32(tableName, "order_id")
	_orderGoodsInfo.GoodsID = field.NewInt32(tableName, "goods_id")
	_orderGoodsInfo.GoodsOptionsID = field.NewInt32(tableName, "goods_options_id")
	_orderGoodsInfo.Count = field.NewInt32(tableName, "count")
	_orderGoodsInfo.Remark = field.NewString(tableName, "remark")
	_orderGoodsInfo.Price = field.NewInt32(tableName, "price")
	_orderGoodsInfo.CouponPrice = field.NewInt32(tableName, "coupon_price")
	_orderGoodsInfo.ActualPrice = field.NewInt32(tableName, "actual_price")
	_orderGoodsInfo.CreatedAt = field.NewTime(tableName, "created_at")
	_orderGoodsInfo.UpdatedAt = field.NewTime(tableName, "updated_at")

	_orderGoodsInfo.fillFieldMap()

	return _orderGoodsInfo
}

// orderGoodsInfo 文章（种草）表
type orderGoodsInfo struct {
	orderGoodsInfoDo orderGoodsInfoDo

	ALL            field.Asterisk
	ID             field.Int32  // 商品维度的订单表
	OrderID        field.Int32  // 关联的主订单表
	GoodsID        field.Int32  // 商品id
	GoodsOptionsID field.Int32  // 商品规格id sku id
	Count          field.Int32  // 商品数量
	Remark         field.String // 备注
	Price          field.Int32  // 订单金额 单位分
	CouponPrice    field.Int32  // 优惠券金额 单位分
	ActualPrice    field.Int32  // 实际支付金额 单位分
	CreatedAt      field.Time
	UpdatedAt      field.Time

	fieldMap map[string]field.Expr
}

func (o orderGoodsInfo) Table(newTableName string) *orderGoodsInfo {
	o.orderGoodsInfoDo.UseTable(newTableName)
	return o.updateTableName(newTableName)
}

func (o orderGoodsInfo) As(alias string) *orderGoodsInfo {
	o.orderGoodsInfoDo.DO = *(o.orderGoodsInfoDo.As(alias).(*gen.DO))
	return o.updateTableName(alias)
}

func (o *orderGoodsInfo) updateTableName(table string) *orderGoodsInfo {
	o.ALL = field.NewAsterisk(table)
	o.ID = field.NewInt32(table, "id")
	o.OrderID = field.NewInt32(table, "order_id")
	o.GoodsID = field.NewInt32(table, "goods_id")
	o.GoodsOptionsID = field.NewInt32(table, "goods_options_id")
	o.Count = field.NewInt32(table, "count")
	o.Remark = field.NewString(table, "remark")
	o.Price = field.NewInt32(table, "price")
	o.CouponPrice = field.NewInt32(table, "coupon_price")
	o.ActualPrice = field.NewInt32(table, "actual_price")
	o.CreatedAt = field.NewTime(table, "created_at")
	o.UpdatedAt = field.NewTime(table, "updated_at")

	o.fillFieldMap()

	return o
}

func (o *orderGoodsInfo) WithContext(ctx context.Context) IOrderGoodsInfoDo {
	return o.orderGoodsInfoDo.WithContext(ctx)
}

func (o orderGoodsInfo) TableName() string { return o.orderGoodsInfoDo.TableName() }

func (o orderGoodsInfo) Alias() string { return o.orderGoodsInfoDo.Alias() }

func (o orderGoodsInfo) Columns(cols ...field.Expr) gen.Columns {
	return o.orderGoodsInfoDo.Columns(cols...)
}

func (o *orderGoodsInfo) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := o.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (o *orderGoodsInfo) fillFieldMap() {
	o.fieldMap = make(map[string]field.Expr, 11)
	o.fieldMap["id"] = o.ID
	o.fieldMap["order_id"] = o.OrderID
	o.fieldMap["goods_id"] = o.GoodsID
	o.fieldMap["goods_options_id"] = o.GoodsOptionsID
	o.fieldMap["count"] = o.Count
	o.fieldMap["remark"] = o.Remark
	o.fieldMap["price"] = o.Price
	o.fieldMap["coupon_price"] = o.CouponPrice
	o.fieldMap["actual_price"] = o.ActualPrice
	o.fieldMap["created_at"] = o.CreatedAt
	o.fieldMap["updated_at"] = o.UpdatedAt
}

func (o orderGoodsInfo) clone(db *gorm.DB) orderGoodsInfo {
	o.orderGoodsInfoDo.ReplaceConnPool(db.Statement.ConnPool)
	return o
}

func (o orderGoodsInfo) replaceDB(db *gorm.DB) orderGoodsInfo {
	o.orderGoodsInfoDo.ReplaceDB(db)
	return o
}

type orderGoodsInfoDo struct{ gen.DO }

type IOrderGoodsInfoDo interface {
	gen.SubQuery
	Debug() IOrderGoodsInfoDo
	WithContext(ctx context.Context) IOrderGoodsInfoDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IOrderGoodsInfoDo
	WriteDB() IOrderGoodsInfoDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IOrderGoodsInfoDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IOrderGoodsInfoDo
	Not(conds ...gen.Condition) IOrderGoodsInfoDo
	Or(conds ...gen.Condition) IOrderGoodsInfoDo
	Select(conds ...field.Expr) IOrderGoodsInfoDo
	Where(conds ...gen.Condition) IOrderGoodsInfoDo
	Order(conds ...field.Expr) IOrderGoodsInfoDo
	Distinct(cols ...field.Expr) IOrderGoodsInfoDo
	Omit(cols ...field.Expr) IOrderGoodsInfoDo
	Join(table schema.Tabler, on ...field.Expr) IOrderGoodsInfoDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IOrderGoodsInfoDo
	RightJoin(table schema.Tabler, on ...field.Expr) IOrderGoodsInfoDo
	Group(cols ...field.Expr) IOrderGoodsInfoDo
	Having(conds ...gen.Condition) IOrderGoodsInfoDo
	Limit(limit int) IOrderGoodsInfoDo
	Offset(offset int) IOrderGoodsInfoDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IOrderGoodsInfoDo
	Unscoped() IOrderGoodsInfoDo
	Create(values ...*model.OrderGoodsInfo) error
	CreateInBatches(values []*model.OrderGoodsInfo, batchSize int) error
	Save(values ...*model.OrderGoodsInfo) error
	First() (*model.OrderGoodsInfo, error)
	Take() (*model.OrderGoodsInfo, error)
	Last() (*model.OrderGoodsInfo, error)
	Find() ([]*model.OrderGoodsInfo, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.OrderGoodsInfo, err error)
	FindInBatches(result *[]*model.OrderGoodsInfo, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.OrderGoodsInfo) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IOrderGoodsInfoDo
	Assign(attrs ...field.AssignExpr) IOrderGoodsInfoDo
	Joins(fields ...field.RelationField) IOrderGoodsInfoDo
	Preload(fields ...field.RelationField) IOrderGoodsInfoDo
	FirstOrInit() (*model.OrderGoodsInfo, error)
	FirstOrCreate() (*model.OrderGoodsInfo, error)
	FindByPage(offset int, limit int) (result []*model.OrderGoodsInfo, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IOrderGoodsInfoDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (o orderGoodsInfoDo) Debug() IOrderGoodsInfoDo {
	return o.withDO(o.DO.Debug())
}

func (o orderGoodsInfoDo) WithContext(ctx context.Context) IOrderGoodsInfoDo {
	return o.withDO(o.DO.WithContext(ctx))
}

func (o orderGoodsInfoDo) ReadDB() IOrderGoodsInfoDo {
	return o.Clauses(dbresolver.Read)
}

func (o orderGoodsInfoDo) WriteDB() IOrderGoodsInfoDo {
	return o.Clauses(dbresolver.Write)
}

func (o orderGoodsInfoDo) Session(config *gorm.Session) IOrderGoodsInfoDo {
	return o.withDO(o.DO.Session(config))
}

func (o orderGoodsInfoDo) Clauses(conds ...clause.Expression) IOrderGoodsInfoDo {
	return o.withDO(o.DO.Clauses(conds...))
}

func (o orderGoodsInfoDo) Returning(value interface{}, columns ...string) IOrderGoodsInfoDo {
	return o.withDO(o.DO.Returning(value, columns...))
}

func (o orderGoodsInfoDo) Not(conds ...gen.Condition) IOrderGoodsInfoDo {
	return o.withDO(o.DO.Not(conds...))
}

func (o orderGoodsInfoDo) Or(conds ...gen.Condition) IOrderGoodsInfoDo {
	return o.withDO(o.DO.Or(conds...))
}

func (o orderGoodsInfoDo) Select(conds ...field.Expr) IOrderGoodsInfoDo {
	return o.withDO(o.DO.Select(conds...))
}

func (o orderGoodsInfoDo) Where(conds ...gen.Condition) IOrderGoodsInfoDo {
	return o.withDO(o.DO.Where(conds...))
}

func (o orderGoodsInfoDo) Order(conds ...field.Expr) IOrderGoodsInfoDo {
	return o.withDO(o.DO.Order(conds...))
}

func (o orderGoodsInfoDo) Distinct(cols ...field.Expr) IOrderGoodsInfoDo {
	return o.withDO(o.DO.Distinct(cols...))
}

func (o orderGoodsInfoDo) Omit(cols ...field.Expr) IOrderGoodsInfoDo {
	return o.withDO(o.DO.Omit(cols...))
}

func (o orderGoodsInfoDo) Join(table schema.Tabler, on ...field.Expr) IOrderGoodsInfoDo {
	return o.withDO(o.DO.Join(table, on...))
}

func (o orderGoodsInfoDo) LeftJoin(table schema.Tabler, on ...field.Expr) IOrderGoodsInfoDo {
	return o.withDO(o.DO.LeftJoin(table, on...))
}

func (o orderGoodsInfoDo) RightJoin(table schema.Tabler, on ...field.Expr) IOrderGoodsInfoDo {
	return o.withDO(o.DO.RightJoin(table, on...))
}

func (o orderGoodsInfoDo) Group(cols ...field.Expr) IOrderGoodsInfoDo {
	return o.withDO(o.DO.Group(cols...))
}

func (o orderGoodsInfoDo) Having(conds ...gen.Condition) IOrderGoodsInfoDo {
	return o.withDO(o.DO.Having(conds...))
}

func (o orderGoodsInfoDo) Limit(limit int) IOrderGoodsInfoDo {
	return o.withDO(o.DO.Limit(limit))
}

func (o orderGoodsInfoDo) Offset(offset int) IOrderGoodsInfoDo {
	return o.withDO(o.DO.Offset(offset))
}

func (o orderGoodsInfoDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IOrderGoodsInfoDo {
	return o.withDO(o.DO.Scopes(funcs...))
}

func (o orderGoodsInfoDo) Unscoped() IOrderGoodsInfoDo {
	return o.withDO(o.DO.Unscoped())
}

func (o orderGoodsInfoDo) Create(values ...*model.OrderGoodsInfo) error {
	if len(values) == 0 {
		return nil
	}
	return o.DO.Create(values)
}

func (o orderGoodsInfoDo) CreateInBatches(values []*model.OrderGoodsInfo, batchSize int) error {
	return o.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (o orderGoodsInfoDo) Save(values ...*model.OrderGoodsInfo) error {
	if len(values) == 0 {
		return nil
	}
	return o.DO.Save(values)
}

func (o orderGoodsInfoDo) First() (*model.OrderGoodsInfo, error) {
	if result, err := o.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.OrderGoodsInfo), nil
	}
}

func (o orderGoodsInfoDo) Take() (*model.OrderGoodsInfo, error) {
	if result, err := o.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.OrderGoodsInfo), nil
	}
}

func (o orderGoodsInfoDo) Last() (*model.OrderGoodsInfo, error) {
	if result, err := o.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.OrderGoodsInfo), nil
	}
}

func (o orderGoodsInfoDo) Find() ([]*model.OrderGoodsInfo, error) {
	result, err := o.DO.Find()
	return result.([]*model.OrderGoodsInfo), err
}

func (o orderGoodsInfoDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.OrderGoodsInfo, err error) {
	buf := make([]*model.OrderGoodsInfo, 0, batchSize)
	err = o.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (o orderGoodsInfoDo) FindInBatches(result *[]*model.OrderGoodsInfo, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return o.DO.FindInBatches(result, batchSize, fc)
}

func (o orderGoodsInfoDo) Attrs(attrs ...field.AssignExpr) IOrderGoodsInfoDo {
	return o.withDO(o.DO.Attrs(attrs...))
}

func (o orderGoodsInfoDo) Assign(attrs ...field.AssignExpr) IOrderGoodsInfoDo {
	return o.withDO(o.DO.Assign(attrs...))
}

func (o orderGoodsInfoDo) Joins(fields ...field.RelationField) IOrderGoodsInfoDo {
	for _, _f := range fields {
		o = *o.withDO(o.DO.Joins(_f))
	}
	return &o
}

func (o orderGoodsInfoDo) Preload(fields ...field.RelationField) IOrderGoodsInfoDo {
	for _, _f := range fields {
		o = *o.withDO(o.DO.Preload(_f))
	}
	return &o
}

func (o orderGoodsInfoDo) FirstOrInit() (*model.OrderGoodsInfo, error) {
	if result, err := o.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.OrderGoodsInfo), nil
	}
}

func (o orderGoodsInfoDo) FirstOrCreate() (*model.OrderGoodsInfo, error) {
	if result, err := o.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.OrderGoodsInfo), nil
	}
}

func (o orderGoodsInfoDo) FindByPage(offset int, limit int) (result []*model.OrderGoodsInfo, count int64, err error) {
	result, err = o.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = o.Offset(-1).Limit(-1).Count()
	return
}

func (o orderGoodsInfoDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = o.Count()
	if err != nil {
		return
	}

	err = o.Offset(offset).Limit(limit).Scan(result)
	return
}

func (o orderGoodsInfoDo) Scan(result interface{}) (err error) {
	return o.DO.Scan(result)
}

func (o orderGoodsInfoDo) Delete(models ...*model.OrderGoodsInfo) (result gen.ResultInfo, err error) {
	return o.DO.Delete(models)
}

func (o *orderGoodsInfoDo) withDO(do gen.Dao) *orderGoodsInfoDo {
	o.DO = *do.(*gen.DO)
	return o
}
