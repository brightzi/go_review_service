// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"gen_demo/dal/model"
)

func newGoodsInfo(db *gorm.DB, opts ...gen.DOOption) goodsInfo {
	_goodsInfo := goodsInfo{}

	_goodsInfo.goodsInfoDo.UseDB(db, opts...)
	_goodsInfo.goodsInfoDo.UseModel(&model.GoodsInfo{})

	tableName := _goodsInfo.goodsInfoDo.TableName()
	_goodsInfo.ALL = field.NewAsterisk(tableName)
	_goodsInfo.ID = field.NewInt32(tableName, "id")
	_goodsInfo.PicURL = field.NewString(tableName, "pic_url")
	_goodsInfo.Name = field.NewString(tableName, "name")
	_goodsInfo.Price = field.NewInt32(tableName, "price")
	_goodsInfo.Level1CategoryID = field.NewInt32(tableName, "level1_category_id")
	_goodsInfo.Level2CategoryID = field.NewInt32(tableName, "level2_category_id")
	_goodsInfo.Level3CategoryID = field.NewInt32(tableName, "level3_category_id")
	_goodsInfo.Brand = field.NewString(tableName, "brand")
	_goodsInfo.Stock = field.NewInt32(tableName, "stock")
	_goodsInfo.Sale = field.NewInt32(tableName, "sale")
	_goodsInfo.Tags = field.NewString(tableName, "tags")
	_goodsInfo.DetailInfo = field.NewString(tableName, "detail_info")
	_goodsInfo.CreatedAt = field.NewTime(tableName, "created_at")
	_goodsInfo.UpdatedAt = field.NewTime(tableName, "updated_at")
	_goodsInfo.DeletedAt = field.NewField(tableName, "deleted_at")

	_goodsInfo.fillFieldMap()

	return _goodsInfo
}

// goodsInfo 商品表
type goodsInfo struct {
	goodsInfoDo goodsInfoDo

	ALL              field.Asterisk
	ID               field.Int32
	PicURL           field.String // 图片
	Name             field.String // 商品名称
	Price            field.Int32  // 价格 单位分
	Level1CategoryID field.Int32  // 1级分类id
	Level2CategoryID field.Int32  // 2级分类id
	Level3CategoryID field.Int32  // 3级分类id
	Brand            field.String // 品牌
	Stock            field.Int32  // 库存
	Sale             field.Int32  // 销量
	Tags             field.String // 标签
	DetailInfo       field.String // 商品详情
	CreatedAt        field.Time
	UpdatedAt        field.Time
	DeletedAt        field.Field

	fieldMap map[string]field.Expr
}

func (g goodsInfo) Table(newTableName string) *goodsInfo {
	g.goodsInfoDo.UseTable(newTableName)
	return g.updateTableName(newTableName)
}

func (g goodsInfo) As(alias string) *goodsInfo {
	g.goodsInfoDo.DO = *(g.goodsInfoDo.As(alias).(*gen.DO))
	return g.updateTableName(alias)
}

func (g *goodsInfo) updateTableName(table string) *goodsInfo {
	g.ALL = field.NewAsterisk(table)
	g.ID = field.NewInt32(table, "id")
	g.PicURL = field.NewString(table, "pic_url")
	g.Name = field.NewString(table, "name")
	g.Price = field.NewInt32(table, "price")
	g.Level1CategoryID = field.NewInt32(table, "level1_category_id")
	g.Level2CategoryID = field.NewInt32(table, "level2_category_id")
	g.Level3CategoryID = field.NewInt32(table, "level3_category_id")
	g.Brand = field.NewString(table, "brand")
	g.Stock = field.NewInt32(table, "stock")
	g.Sale = field.NewInt32(table, "sale")
	g.Tags = field.NewString(table, "tags")
	g.DetailInfo = field.NewString(table, "detail_info")
	g.CreatedAt = field.NewTime(table, "created_at")
	g.UpdatedAt = field.NewTime(table, "updated_at")
	g.DeletedAt = field.NewField(table, "deleted_at")

	g.fillFieldMap()

	return g
}

func (g *goodsInfo) WithContext(ctx context.Context) IGoodsInfoDo {
	return g.goodsInfoDo.WithContext(ctx)
}

func (g goodsInfo) TableName() string { return g.goodsInfoDo.TableName() }

func (g goodsInfo) Alias() string { return g.goodsInfoDo.Alias() }

func (g goodsInfo) Columns(cols ...field.Expr) gen.Columns { return g.goodsInfoDo.Columns(cols...) }

func (g *goodsInfo) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := g.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (g *goodsInfo) fillFieldMap() {
	g.fieldMap = make(map[string]field.Expr, 15)
	g.fieldMap["id"] = g.ID
	g.fieldMap["pic_url"] = g.PicURL
	g.fieldMap["name"] = g.Name
	g.fieldMap["price"] = g.Price
	g.fieldMap["level1_category_id"] = g.Level1CategoryID
	g.fieldMap["level2_category_id"] = g.Level2CategoryID
	g.fieldMap["level3_category_id"] = g.Level3CategoryID
	g.fieldMap["brand"] = g.Brand
	g.fieldMap["stock"] = g.Stock
	g.fieldMap["sale"] = g.Sale
	g.fieldMap["tags"] = g.Tags
	g.fieldMap["detail_info"] = g.DetailInfo
	g.fieldMap["created_at"] = g.CreatedAt
	g.fieldMap["updated_at"] = g.UpdatedAt
	g.fieldMap["deleted_at"] = g.DeletedAt
}

func (g goodsInfo) clone(db *gorm.DB) goodsInfo {
	g.goodsInfoDo.ReplaceConnPool(db.Statement.ConnPool)
	return g
}

func (g goodsInfo) replaceDB(db *gorm.DB) goodsInfo {
	g.goodsInfoDo.ReplaceDB(db)
	return g
}

type goodsInfoDo struct{ gen.DO }

type IGoodsInfoDo interface {
	gen.SubQuery
	Debug() IGoodsInfoDo
	WithContext(ctx context.Context) IGoodsInfoDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IGoodsInfoDo
	WriteDB() IGoodsInfoDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IGoodsInfoDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IGoodsInfoDo
	Not(conds ...gen.Condition) IGoodsInfoDo
	Or(conds ...gen.Condition) IGoodsInfoDo
	Select(conds ...field.Expr) IGoodsInfoDo
	Where(conds ...gen.Condition) IGoodsInfoDo
	Order(conds ...field.Expr) IGoodsInfoDo
	Distinct(cols ...field.Expr) IGoodsInfoDo
	Omit(cols ...field.Expr) IGoodsInfoDo
	Join(table schema.Tabler, on ...field.Expr) IGoodsInfoDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IGoodsInfoDo
	RightJoin(table schema.Tabler, on ...field.Expr) IGoodsInfoDo
	Group(cols ...field.Expr) IGoodsInfoDo
	Having(conds ...gen.Condition) IGoodsInfoDo
	Limit(limit int) IGoodsInfoDo
	Offset(offset int) IGoodsInfoDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IGoodsInfoDo
	Unscoped() IGoodsInfoDo
	Create(values ...*model.GoodsInfo) error
	CreateInBatches(values []*model.GoodsInfo, batchSize int) error
	Save(values ...*model.GoodsInfo) error
	First() (*model.GoodsInfo, error)
	Take() (*model.GoodsInfo, error)
	Last() (*model.GoodsInfo, error)
	Find() ([]*model.GoodsInfo, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.GoodsInfo, err error)
	FindInBatches(result *[]*model.GoodsInfo, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.GoodsInfo) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IGoodsInfoDo
	Assign(attrs ...field.AssignExpr) IGoodsInfoDo
	Joins(fields ...field.RelationField) IGoodsInfoDo
	Preload(fields ...field.RelationField) IGoodsInfoDo
	FirstOrInit() (*model.GoodsInfo, error)
	FirstOrCreate() (*model.GoodsInfo, error)
	FindByPage(offset int, limit int) (result []*model.GoodsInfo, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IGoodsInfoDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (g goodsInfoDo) Debug() IGoodsInfoDo {
	return g.withDO(g.DO.Debug())
}

func (g goodsInfoDo) WithContext(ctx context.Context) IGoodsInfoDo {
	return g.withDO(g.DO.WithContext(ctx))
}

func (g goodsInfoDo) ReadDB() IGoodsInfoDo {
	return g.Clauses(dbresolver.Read)
}

func (g goodsInfoDo) WriteDB() IGoodsInfoDo {
	return g.Clauses(dbresolver.Write)
}

func (g goodsInfoDo) Session(config *gorm.Session) IGoodsInfoDo {
	return g.withDO(g.DO.Session(config))
}

func (g goodsInfoDo) Clauses(conds ...clause.Expression) IGoodsInfoDo {
	return g.withDO(g.DO.Clauses(conds...))
}

func (g goodsInfoDo) Returning(value interface{}, columns ...string) IGoodsInfoDo {
	return g.withDO(g.DO.Returning(value, columns...))
}

func (g goodsInfoDo) Not(conds ...gen.Condition) IGoodsInfoDo {
	return g.withDO(g.DO.Not(conds...))
}

func (g goodsInfoDo) Or(conds ...gen.Condition) IGoodsInfoDo {
	return g.withDO(g.DO.Or(conds...))
}

func (g goodsInfoDo) Select(conds ...field.Expr) IGoodsInfoDo {
	return g.withDO(g.DO.Select(conds...))
}

func (g goodsInfoDo) Where(conds ...gen.Condition) IGoodsInfoDo {
	return g.withDO(g.DO.Where(conds...))
}

func (g goodsInfoDo) Order(conds ...field.Expr) IGoodsInfoDo {
	return g.withDO(g.DO.Order(conds...))
}

func (g goodsInfoDo) Distinct(cols ...field.Expr) IGoodsInfoDo {
	return g.withDO(g.DO.Distinct(cols...))
}

func (g goodsInfoDo) Omit(cols ...field.Expr) IGoodsInfoDo {
	return g.withDO(g.DO.Omit(cols...))
}

func (g goodsInfoDo) Join(table schema.Tabler, on ...field.Expr) IGoodsInfoDo {
	return g.withDO(g.DO.Join(table, on...))
}

func (g goodsInfoDo) LeftJoin(table schema.Tabler, on ...field.Expr) IGoodsInfoDo {
	return g.withDO(g.DO.LeftJoin(table, on...))
}

func (g goodsInfoDo) RightJoin(table schema.Tabler, on ...field.Expr) IGoodsInfoDo {
	return g.withDO(g.DO.RightJoin(table, on...))
}

func (g goodsInfoDo) Group(cols ...field.Expr) IGoodsInfoDo {
	return g.withDO(g.DO.Group(cols...))
}

func (g goodsInfoDo) Having(conds ...gen.Condition) IGoodsInfoDo {
	return g.withDO(g.DO.Having(conds...))
}

func (g goodsInfoDo) Limit(limit int) IGoodsInfoDo {
	return g.withDO(g.DO.Limit(limit))
}

func (g goodsInfoDo) Offset(offset int) IGoodsInfoDo {
	return g.withDO(g.DO.Offset(offset))
}

func (g goodsInfoDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IGoodsInfoDo {
	return g.withDO(g.DO.Scopes(funcs...))
}

func (g goodsInfoDo) Unscoped() IGoodsInfoDo {
	return g.withDO(g.DO.Unscoped())
}

func (g goodsInfoDo) Create(values ...*model.GoodsInfo) error {
	if len(values) == 0 {
		return nil
	}
	return g.DO.Create(values)
}

func (g goodsInfoDo) CreateInBatches(values []*model.GoodsInfo, batchSize int) error {
	return g.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (g goodsInfoDo) Save(values ...*model.GoodsInfo) error {
	if len(values) == 0 {
		return nil
	}
	return g.DO.Save(values)
}

func (g goodsInfoDo) First() (*model.GoodsInfo, error) {
	if result, err := g.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.GoodsInfo), nil
	}
}

func (g goodsInfoDo) Take() (*model.GoodsInfo, error) {
	if result, err := g.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.GoodsInfo), nil
	}
}

func (g goodsInfoDo) Last() (*model.GoodsInfo, error) {
	if result, err := g.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.GoodsInfo), nil
	}
}

func (g goodsInfoDo) Find() ([]*model.GoodsInfo, error) {
	result, err := g.DO.Find()
	return result.([]*model.GoodsInfo), err
}

func (g goodsInfoDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.GoodsInfo, err error) {
	buf := make([]*model.GoodsInfo, 0, batchSize)
	err = g.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (g goodsInfoDo) FindInBatches(result *[]*model.GoodsInfo, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return g.DO.FindInBatches(result, batchSize, fc)
}

func (g goodsInfoDo) Attrs(attrs ...field.AssignExpr) IGoodsInfoDo {
	return g.withDO(g.DO.Attrs(attrs...))
}

func (g goodsInfoDo) Assign(attrs ...field.AssignExpr) IGoodsInfoDo {
	return g.withDO(g.DO.Assign(attrs...))
}

func (g goodsInfoDo) Joins(fields ...field.RelationField) IGoodsInfoDo {
	for _, _f := range fields {
		g = *g.withDO(g.DO.Joins(_f))
	}
	return &g
}

func (g goodsInfoDo) Preload(fields ...field.RelationField) IGoodsInfoDo {
	for _, _f := range fields {
		g = *g.withDO(g.DO.Preload(_f))
	}
	return &g
}

func (g goodsInfoDo) FirstOrInit() (*model.GoodsInfo, error) {
	if result, err := g.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.GoodsInfo), nil
	}
}

func (g goodsInfoDo) FirstOrCreate() (*model.GoodsInfo, error) {
	if result, err := g.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.GoodsInfo), nil
	}
}

func (g goodsInfoDo) FindByPage(offset int, limit int) (result []*model.GoodsInfo, count int64, err error) {
	result, err = g.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = g.Offset(-1).Limit(-1).Count()
	return
}

func (g goodsInfoDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = g.Count()
	if err != nil {
		return
	}

	err = g.Offset(offset).Limit(limit).Scan(result)
	return
}

func (g goodsInfoDo) Scan(result interface{}) (err error) {
	return g.DO.Scan(result)
}

func (g goodsInfoDo) Delete(models ...*model.GoodsInfo) (result gen.ResultInfo, err error) {
	return g.DO.Delete(models)
}

func (g *goodsInfoDo) withDO(do gen.Dao) *goodsInfoDo {
	g.DO = *do.(*gen.DO)
	return g
}
